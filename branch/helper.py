import numpy as np
import sys
import ast
import operator as op


# supported operators
operators = {ast.Add: op.add, ast.Sub: op.sub, ast.Mult: op.mul,
             ast.Div: op.truediv, ast.Pow: op.pow, ast.BitXor: op.xor,
             ast.USub: op.neg}


# #####################################################################################################################
# ###################################################               ###################################################
# #################################################    helper func    #################################################
# source: https://stackoverflow.com/questions/2371436/evaluating-a-mathematical-expression-in-a-string
# ###################################################               ###################################################
# #####################################################################################################################
def eval_expr(expr):
    """
    >>> eval_expr('2^6')
    4
    >>> eval_expr('2**6')
    64
    >>> eval_expr('1 + 2*3**(4^5) / (6 + -7)')
    -5.0
    """
    return eval_(ast.parse(expr, mode='eval').body)


def eval_(node):
    """part of helper func above"""
    if isinstance(node, ast.Num): # <number>
        return node.n
    elif isinstance(node, ast.BinOp): # <left> <operator> <right>
        return operators[type(node.op)](eval_(node.left), eval_(node.right))
    elif isinstance(node, ast.UnaryOp): # <operator> <operand> e.g., -1
        return operators[type(node.op)](eval_(node.operand))
    else:
        raise TypeError(node)


# #####################################################################################################################
# ###################################################               ###################################################
# ##################################################    return gcd    #################################################
# ###################################################               ###################################################
# #####################################################################################################################
def gcd(a, b):
    """Return greatest common divisor using Euclid's Algorithm."""
    while b:
        a, b = b, a % b
    return a


# #####################################################################################################################
# ###################################################               ###################################################
# ##################################################    read lcm     ##################################################
# ###################################################               ###################################################
# #####################################################################################################################
def lcm(a, b):
    """Return lowest common multiple."""
    return a * b // gcd(a, b)


# #####################################################################################################################
# ###################################################               ###################################################
# #################################################    helper func    #################################################
# source: https://stackoverflow.com/questions/21583758/how-to-check-if-a-float-value-is-a-whole-number
# ###################################################               ###################################################
# #####################################################################################################################
def isclose(a, b, rel_tol=1e-9, abs_tol=0.0):
    return abs(a - b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)


# #####################################################################################################################
# ###################################################               ###################################################
# #################################################    helper func    #################################################
# https://stackoverflow.com/questions/1265665/python-check-if-a-string-represents-an-int-without-using-try-except
#  ###################################################               ###################################################
# #####################################################################################################################
def RepresentsInt(s):
    try:
        int(s)
        return True
    except ValueError:
        return False


# #####################################################################################################################
# ###################################################               ###################################################
# #################################################    read in file    ################################################
# ###################################################               ###################################################
# #####################################################################################################################
def read_input_file():
    # input file
    f = open(sys.argv[1],"r")

    # get integers on line 1
    int1, int2 = map(int, f.readline().split())

    # get vectors b and c^T
    b_str = f.readline().split()
    # b = np.empty(0)
    # for val in b_str.split(" "):
    #     if isclose(float(eval_expr(val)), int(round(eval_expr(val), 10))):
    #         b = np.append(b, int(round(eval_expr(val), 10)))
    #     else:
    #         b = np.append(b, float(eval_expr(val)))
    b = np.array(map(float, b_str))
    cT_str = f.readline().split()
    # cT = np.empty(0)
    # for val in cT_str.split(" "):
    #     if isclose(float(eval_expr(val)), int(round(eval_expr(val), 10))):
    #         cT = np.append(cT, int(round(eval_expr(val), 10)))
    #     else:
    #         cT = np.append(cT, float(eval_expr(val)))
    cT = np.array(map(float, cT_str))

    # get matrix A
    matrix = []
    for line in f.readlines():
        row = []
        for val in line.split():
             if isclose(float(eval_expr(val)), int(round(eval_expr(val), 10))):
                 row.append(int(round(eval_expr(val), 10)))
             else:
                 row.append(float(round(eval_expr(val), 7)))
            #row.append(float(val))
        matrix.append(row)
    A = np.matrix(matrix)

    # return values
    return int1, int2, b, cT, A


# #####################################################################################################################
# ###################################################               ###################################################
# #################################################   write output   ##################################################
# ###################################################               ###################################################
# #####################################################################################################################
def write_to_file(s):
    output = open("branch.out",'w')
    output.write(str(s))


# #####################################################################################################################
# ###################################################               ###################################################
# ##############################################       Make Tableau       #############################################
# ###################################################               ###################################################
# #####################################################################################################################
# Takes a coefficient vector c^T, constraint matrix A, and basic solution b to form simplex tableau
def make_tableau(cT, A, b):
    n = A.shape[0]
    neg_cT = np.negative(cT.copy())
    slack_vars = np.identity(n)
    tableau = np.array(A)
    tableau = np.hstack((tableau, slack_vars))
    tableau = np.column_stack((tableau, b))
    neg_cT = np.append(neg_cT, np.zeros(n))
    neg_cT = np.append(neg_cT, [0])
    tableau = np.vstack((tableau, neg_cT))
    return tableau
